Sqlg Documentation
==================
Pieter Martin
v1.3.3, December 2016:

'https://github.com/pietermartin/sqlg[*Sqlg*]' is a implementation of 'http://tinkerpop.apache.org/[Apache TinkerPop]' on a 'http://en.wikipedia.org/wiki/Relational_database_management_system[RDBMS]'.
Currently 'http://www.postgresql.org/[Postgresql]', 'http://hsqldb.org/[HSQLDB]', and 'http://h2database.com[H2 database]' are supported.

== Introduction

Sqlg primary challenge is to reduce latency by combining TinkerPop 'http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps[steps]'
into as few as possible database calls. The fine grained nature of graph traversals makes this crucial else the remote
call latency has a severe performance impact.

Additionally for Postgresql Sqlg supports various bulk modes to reduce latency when modifying the graph.

[NOTE]
Hsqldb and H2 do not suffer the same latency as Postgresql as it runs embedded in the jvm.

== TinkerPop supported features

Sqlg version 1.3.3 runs on TinkerPop 3.2.3

Sqlg passes TinkerPop's `StructureStandardSuite` and `ProcessStandardSuite` test suites.

.Graph Features *not* implemented.

- Computer
- ThreadedTransactions
- Variables

.Vertex Features *not* implemented.

- MultiProperties
- MetaProperties
- UserSuppliedIds
- NumericIds
- StringIds
- UuidIds
- CustomIds
- AnyIds

.Edge Features **not** implemented.

- UserSuppliedIds
- NumericIds
- StringIds
- UuidIds
- CustomIds
- AnyIds

.Vertex property features *not* implemented.

- AddProperty
- RemoveProperty
- UserSuppliedIds
- NumericIds
- StringIds
- UuidIds
- CustomIds
- AnyIds
- MapValues
- MixedListValues
- SerializableValues
- UniformListValues

.Edge property feature *not* implemented.

- MapValues
- MixedListValues
- SerializableValues
- UniformListValues

== Getting Started

=== Maven coordinates

.Postgresql
 <dependency>
     <groupId>org.umlg</groupId>
     <artifactId>sqlg-postgres</artifactId>
     <version>1.3.3</version>
 </dependency>

.HSQLDB
 <dependency>
     <groupId>org.umlg</groupId>
     <artifactId>sqlg-hsqldb</artifactId>
     <version>1.3.3</version>
 </dependency>

.H2
 <dependency>
     <groupId>org.umlg</groupId>
     <artifactId>sqlg-h2</artifactId>
     <version>1.3.3</version>
 </dependency>

This will include `gremlin-groovy`. If you have no need for that then use the following coordinates.

.Postgresql
 <dependency>
     <groupId>org.umlg</groupId>
     <artifactId>sqlg-postgres-dialect</artifactId>
     <version>1.3.3</version>
 </dependency>

.HSQLDB
 <dependency>
     <groupId>org.umlg</groupId>
     <artifactId>sqlg-hsqldb-dialect</artifactId>
     <version>1.3.3</version>
 </dependency>

.H2
 <dependency>
     <groupId>org.umlg</groupId>
     <artifactId>sqlg-h2-dialect</artifactId>
     <version>1.3.3</version>
 </dependency>

=== Running

Sqlg runs as a singleton that can be shared among multiple threads. You instantiate Sqlg using the standard
TinkerPop static constructors.

* `SqlgGraph.open(final Configuration configuration)`
* `SqlgGraph.open(final String pathToSqlgProperties)`

The configuration object requires the following properties.

.Postgresql
 jdbc.url=jdbc:postgresql://localhost:5432/yourdb
 jdbc.username=postgres
 jdbc.password=******

.HSQLDB
 jdbc.url=jdbc:hsqldb:file:/tmp/yourdb
 jdbc.username=SA
 jdbc.password=

.H2
 jdbc.url=jdbc:h2:file:target/tmp/yourdb
 jdbc.username=SA
 jdbc.password=

In the case of Postgresql the database must already exist.

=== Tests

If you want to run the TinkerPop tests on Postgresql you need to create the various databases that are used.

.These are,
 g1
 g2
 readGraph
 standard
 temp
 temp1
 temp2
 subgraph
 prototype
 target

=== Gremlin Console

.Postgresql
 [pieter@pieter-laptop bin]$ ./gremlin.sh
          \,,,/
          (o o)
 -----oOOo-(3)-oOOo-----
 plugin activated: tinkerpop.server
 plugin activated: tinkerpop.utilities
 plugin activated: tinkerpop.tinkergraph
 gremlin> :install org.umlg sqlg-postgres 1.3.3
 log4j:WARN No appenders could be found for logger (org.apache.tinkerpop.gremlin.groovy.util.DependencyGrabber).
 log4j:WARN Please initialize the log4j system properly.
 log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
 ==>Loaded: [org.umlg, sqlg-postgres, 1.3.3]
 gremlin> :plugin list
 ==>tinkerpop.server[active]
 ==>tinkerpop.gephi
 ==>tinkerpop.utilities[active]
 ==>tinkerpop.sugar
 ==>tinkerpop.credentials
 ==>tinkerpop.tinkergraph[active]
 ==>sqlg.postgres
 gremlin> :plugin use sqlg.postgres
 ==>sqlg.postgres activated
 gremlin> graph = SqlgGraph.open('pathTo/sqlg.properties')
 ==>sqlggraph[SqlGraph]
 gremlin> g = graph.traversal()
 ==>sqlggraphtraversalsource[sqlggraph[SqlGraph] (jdbc:postgresql://localhost:5432/sqlgraphdb), standard]
 gremlin> graph.io(graphml()).readGraph('pathTo/grateful-dead.xml')
 ==>null
 gremlin> g.V().count()
 ==>808
 gremlin>

.HSQLDB
 [pieter@pieter-laptop bin]$ ./gremlin.sh

          \,,,/
          (o o)
 -----oOOo-(3)-oOOo-----
 plugin activated: tinkerpop.server
 plugin activated: tinkerpop.utilities
 plugin activated: tinkerpop.tinkergraph
 gremlin> :install org.umlg sqlg-hsqldb 1.3.3
 log4j:WARN No appenders could be found for logger (org.apache.tinkerpop.gremlin.groovy.util.DependencyGrabber).
 log4j:WARN Please initialize the log4j system properly.
 log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
 ==>Loaded: [org.umlg, sqlg-hsqldb, 1.3.3]
 gremlin> :plugin list
 ==>tinkerpop.server[active]
 ==>tinkerpop.gephi
 ==>tinkerpop.utilities[active]
 ==>tinkerpop.sugar
 ==>tinkerpop.credentials
 ==>tinkerpop.tinkergraph[active]
 ==>sqlg.hsqldb
 gremlin> :plugin use sqlg.hsqldb
 ==>sqlg.hsqldb activated
 gremlin> graph = SqlgGraph.open('pathTo/sqlg.properties')
 ==>sqlggraph[SqlGraph]
 gremlin> g = graph.traversal()
 ==>sqlggraphtraversalsource[sqlggraph[SqlGraph] (jdbc:hsqldb:file:src/test/db/sqlgraphdb), standard]
 gremlin> graph.io(graphml()).readGraph('pathTo/grateful-dead.xml')
 ==>null
 gremlin> g.V().count()
 ==>808
 gremlin>

== Data types

.Table Data types
|===
|Java |Postgresql |HSQLDB |H2

|Boolean
|BOOLEAN
|BOOLEAN
|BOOLEAN

|Byte
|*Not supported*
|TINYINT
|TINYINT

|Short
|SMALLINT
|SMALLINT
|SMALLINT

|Integer
|INTEGER
|INTEGER
|INT

|Long
|BIGINT
|BIGINT
|BIGINT

|Float
|REAL
|*Not supported*
|REAL

|Double
|DOUBLE PRECISION
|DOUBLE
|DOUBLE

|String
|TEXT
|LONGVARCHAR
|VARCHAR

|Boolean[]
|BOOLEAN[]
|BOOLEAN ARRAY DEFAULT ARRAY[]
|ARRAY

|Byte[]
|BYTEA
|LONGVARBINARY
|BINARY

|Short[]
|SMALLINT[]
|SMALLINT ARRAY DEFAULT ARRAY[]
|ARRAY

|Integer[]
|INTEGER[]
|INTEGER ARRAY DEFAULT ARRAY[]
|ARRAY

|Long[]
|BIGINT[]
|BIGINT ARRAY DEFAULT ARRAY[]
|ARRAY

|Float[]
|REAL[]
|*Not supported*
|ARRAY

|Double[]
|DOUBLE PRECISION[]
|DOUBLE ARRAY DEFAULT ARRAY[]
|ARRAY

|String[]
|TEXT[]
|LONGVARCHAR ARRAY DEFAULT ARRAY[]
|ARRAY

|java.time.LocalDateTime
|TIMESTAMP WITH TIME ZONE
|TIMESTAMP WITH TIME ZONE
|TIMESTAMP

|java.time.LocalDate
|DATE
|DATE
|DATE

|java.time.LocalTime
|TIME WITH TIME ZONE
|TIME WITH TIME ZONE
|TIME

|java.time.ZonedDateTime
|TIMESTAMP WITH TIME ZONE, TEXT
|TIMESTAMP WITH TIME ZONE, LONGVARCHAR
|TIMESTAMP, VARCHAR

|java.time.Period
|INTEGER, INTEGER, INTEGER
|INTEGER, INTEGER, INTEGER
|INT, INT, INT

|java.time.Duration
|BIGINT, INTEGER
|BIGINT, INTEGER
|BIGINT, INT

|java.time.LocalDateTime[]
|TIMESTAMP WITH TIME ZONE[]
|TIMESTAMP WITH TIME ZONE ARRAY DEFAULT ARRAY[]
|ARRAY

|java.time.LocalDate[]
|DATE[]
|DATE ARRAY DEFAULT ARRAY[]
|ARRAY

|java.time.LocalTime[]
|TIME WITH TIME ZONE ARRAY DEFAULT ARRAY[]
|TIME WITH TIME ZONE[]
|ARRAY

|java.time.ZonedDateTime[]
|TIMESTAMP WITH TIME ZONE[], TEXT[]
|TIMESTAMP WITH TIME ZONE ARRAY DEFAULT ARRAY[], LONGVARCHAR ARRAY DEFAULT ARRAY[]
|ARRAY

|java.time.Period[]
|INTEGER[], INTEGER[], INTEGER[]
|INTEGER ARRAY DEFAULT ARRAY[], INTEGER ARRAY DEFAULT ARRAY[], INTEGER ARRAY DEFAULT ARRAY[]
|ARRAY

|java.time.Duration[]
|BIGINT[], INTEGER[]
|BIGINT ARRAY DEFAULT ARRAY[], INTEGER ARRAY DEFAULT ARRAY[]
|ARRAY

|com.fasterxml.jackson.databind.JsonNode
|JSONB
|*Not supported*
|*Not supported*

|com.fasterxml.jackson.databind.JsonNode[]
|JSONB[]
|*Not supported*
|*Not supported*

|org.postgis.Point
|geometry(POINT)
|*Not supported*
|*Not supported*

|org.umlg.sqlg.gis.GeographyPoint
|geography(POINT, 4326)
|*Not supported*
|*Not supported*

|org.postgis.LineString
|geometry(LINESTRING)
|*Not supported*
|*Not supported*

|org.postgis.Polygon
|geometry(POLYGON)
|*Not supported*
|*Not supported*

|org.umlg.sqlg.gis.GeographyPolygon
|geography(POLYGON, 4326)
|*Not supported*
|*Not supported*
|===

[NOTE]
`java.time.LocalTime` drops the nano second precision.

== Architecture

With the coming of vertex labels to TinkerPop the mapping of TinkerPop's graph semantics to that of a RDBMS became natural and useful.

=== Vertex tables
Every unique vertex label maps to a table. Vertex tables are prefixed with a `V_`. i.e. `V_Person`. The vertex table
stores the vertex's properties.

=== Edge tables
Every unique edge label maps to a table. Edge tables are prefixed with a `E_`. i.e. `E_friend`. The edge table stores
each edge's adjacent vertex ids and the edge properties. The column corresponding to each adjacent vertex id (`IN` and `OUT`)
has a foreign key to the adjacent vertex's table. The foreign key is optional, instead just an index on the adjacent vertex id
can be used.

From a rdbms' perspective each edge table is the classic `many to many` join table between vertices.

=== TinkerPop-modern

Taken from 'http://tinkerpop.apache.org/docs/current/reference/#intro[TinkerPop]'

image:src/main/images/sqlg/tinkerpop-modern-graph.png[image of tinkerpop-classic]

==== ER Diagram

image:src/main/images/sqlg/tinkerpop-modern-er.png[image of tinkerpop-classic]

==== V_person

image:src/main/images/sqlg/V_person.png[image of tinkerpop-classic]

==== V_software

image:src/main/images/sqlg/V_software.png[image of tinkerpop-classic]

==== E_knows

image:src/main/images/sqlg/E_knows.png[image of tinkerpop-classic]

==== E_created

image:src/main/images/sqlg/E_created.png[image of tinkerpop-classic]

=== Namespacing and Schemas

Many RDBMS databases have the notion of a `schema` as a namespace for tables. Sqlg supports schemas
for vertex labels. Distinct schemas for edge tables are unnecessary as edge tables are created in the schema of the adjacent `out` vertex.
By default schemas for vertex tables go into the underlying databases' default schema. For Postgresql, hsqldb and H2 this
is the `public` schema.

To specify the schema for a label Sqlg uses the dot `.` notation.

    Vertex john = this.sqlgGraph.addVertex(T.label, "manager", "name", "john");
    Vertex palace1 = this.sqlgGraph.addVertex(T.label, "continent.house", "name", "palace1");
    Vertex corrola = this.sqlgGraph.addVertex(T.label, "fleet.car", "model", "corrola");
    palace1.addEdge("managedBy", john);
    corrola.addEdge("owner", john);

This will create a table `V_manager` in the `public` (default) schema. Table `V_house` is in the `continent` schema and table `V_car`
is in the `fleet` schema.
For the `managedBy` edge a `E_managedBy` table is created in the `continent` schema as its `out` vertex `palace1` is in the `continent` schema and
for the `owner` edge a `E_owner` table is created in the `fleet` schema as its `out` vertex is in the `fleet`schema.

==== Schemas

image:src/main/images/sqlg/schemas.png[image of tinkerpop-classic]
image:src/main/images/sqlg/continent.png[image of tinkerpop-classic]
image:src/main/images/sqlg/fleet.png[image of tinkerpop-classic]
image:src/main/images/sqlg/public.png[image of tinkerpop-classic]

== Indexes

=== Basic indexing

Sqlg supports adding a unique or non-unique index to any property.

To add an index one has to use Sqlg's topology interface.

    this.sqlgGraph.addVertex(T.label, "Person", "name", "john");
    Optional<VertexLabel> personVertexOptional = this.sqlgGraph.getTopology().getVertexLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), "Person");
    Preconditions.checkState(personVertexOptional.isPresent());
    Optional<PropertyColumn> namePropertyOptional = personVertexOptional.get().getProperty("name");
    Preconditions.checkState(namePropertyOptional.isPresent());
    //Create the index
    Index index = personVertexOptional.get().ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(namePropertyOptional.get()));

Outside of creating the index Sqlg has no further direct interaction with the index. However gremlin queries with a
`has` step will translate to a sql `where` clause. If an index has been created on the property of the `has` step then
the underlying RDBMS will utilize that index on that property's column.

The index does not need to be created upfront. It can be added any time.
